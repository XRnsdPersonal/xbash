#!/bin/bash

ftAutoInitEnv()
{
    local ftEffect=初始化xbash_Android_build相关所需的部分环境变量
    local isEnable=true

    while true; do case "$1" in
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    ftAutoInitEnv 无参
#    ftAutoInitEnv -bp #强制解析build.prop信息
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT buildType=$TARGET_BUILD_VARIANT
    local editType=$1
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ]\
        ||[ -z "$TARGET_PRODUCT" ];then
        local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
        local dirPathLocal=$(pwd)
        if [  -d "${dirPathLocal}/out" ] && [ -n "$branchName" ];then
            export ANDROID_BUILD_TOP=$dirPathLocal
            dirPathCode=$ANDROID_BUILD_TOP
            dirPathOut=${ANDROID_BUILD_TOP}/out/target/product
            if [[ -d $dirPathOut ]]; then
                        while read item ;do
                           if [[ -f ${dirPathOut}/${item}/system/build.prop ]]; then
                                dirPathOut="${dirPathOut}/${item}"
                                export TARGET_PRODUCT=full_${item}
                                export ANDROID_PRODUCT_OUT=$dirPathOut
                                ftAutoInitEnv $@
                                return
                           fi
                        done < <(echo "$(ls $dirPathOut)")
            fi
        else
            ftAutoInitEnv --env
        fi
        return
    fi
    local valCount=2 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoInitEnv -h && return

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    # 项目平台
    local dirPathVendor=${dirPathCode}/vendor
    if [ -d $dirPathVendor ];then
            dirList=$(ls $dirPathVendor)
            for item in $dirList ; do
                if [ $item = "sprd" ];then
                     local mnufacturers=sprd
                    #device路径
                    export AutoEnv_deviceDirPath=
                    local dirPathDevice=$(find device/ -name "$(basename $ANDROID_PRODUCT_OUT)")
                    [[ -d "$dirPathDevice" ]] && export AutoEnv_deviceDirPath=$dirPathDevice

                     continue
                fi
                [ $item = "mediatek" ] && local mnufacturers=mtk
            done
    fi
    export AutoEnv_mnufacturers=
    [[ -z "$mnufacturers" ]] && ftEcho -e "未找到 $dirPathVendor\n mnufacturers[项目平台] 获取失败" || \
    export AutoEnv_mnufacturers=$mnufacturers


    #软件版本名
    export AutoEnv_versionName=
    local filePathOutBuildProp=${dirPathOut}/system/build.prop
    if [ -f $filePathOutBuildProp ];then
            local keyVersion="ro.build.display.id="
            local versionName=$(cat $filePathOutBuildProp|grep $keyVersion)
            versionName=${versionName//$keyVersion/}
            if [[ -n "$LZ_BUILD_VERSION" ]]&&[[ "$versionName" != "$LZ_BUILD_VERSION" ]]; then
                    ftEcho -e "环境与本地，软件版本不一致:\n本地:${versionName}\n环境:${LZ_BUILD_VERSION}"
            fi
    elif [[ -n "$LZ_BUILD_VERSION" ]];then
            local versionName=$LZ_BUILD_VERSION
    fi
    [ -z "$versionName" ] && versionName=$(basename $ANDROID_PRODUCT_OUT)
    versionName=${versionName// /_}
    versionName=${versionName//
/_}
    [[ -n "$versionName" ]] && export AutoEnv_versionName=$versionName

    #软件编译类型
    if [ -d $dirPathOut ];then
            local filePathBuildInfo=${dirPathOut}/system/build.prop
            local filePathPreviousBuildConfig=${dirPathOut}/previous_build_config.mk
            if [ -f $filePathBuildInfo ];then
                        local keybuildType="ro.build.type="
                        local buildTypeFile
                        if [ -f "$filePathBuildInfo" ];then
                            buildTypeFile=$(cat $filePathBuildInfo|grep $keybuildType)
                            if [[ -n "$buildTypeFile" ]];then
                                buildTypeFile=${buildTypeFile/$keybuildType/}
                                if [[ -n "$buildType" ]];then
                                    if [ "$buildType" != "$buildTypeFile" ];then
                                        ftEcho -e "环境与本地，编译类型不一致:\n本地:$buildTypeFile\n环境:$buildType"
                                        buildType=$buildTypeFile
                                    fi
                                else
                                    buildType=$buildTypeFile
                                fi
                            else
                                ftEcho -e "[$filePathBuildInfo]中未找到编译类型"
                            fi
                        fi
            else
                        ftEcho -e "未找到 $filePathBuildInfo\n build Type[本地] 获取失败"

                        if [ -f "$filePathPreviousBuildConfig" ];then
                                info=$(cat $filePathPreviousBuildConfig|grep $TARGET_PRODUCT)
                                if [[ -n "$info" ]];then

                                    local OLD_IFS="$IFS"
                                    IFS="-"
                                    local arrayItems=($info)
                                    IFS="$OLD_IFS"
                                    if [ "$info" = "$arrayItems" ];then
                                            ftEcho -e "${filePathPreviousBuildConfig} 信息解析失败"
                                    else
                                            local buildinfo=null
                                            for item in ${arrayItems[@]} ;  do
                                                if [[ "$item" = "$TARGET_PRODUCT" ]]; then
                                                    buildinfo=
                                                elif [[ -z "$buildinfo" ]]; then
                                                    buildType=$item
                                                    buildinfo=$buildType
                                                fi
                                            done
                                    fi
                                fi
                        fi
            fi
    fi
    export AutoEnv_buildType=$buildType

    #git分支信息解析
   ftBranchNameResolution

    cd $dirPathLocal
    trap SIGINT
}

complete -W "-h --help" ftBranchNameResolution
ftBranchNameResolution()
{
    local ftEffect=分支名解析
    local isEnable=true

    while true; do case "$1" in
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的依赖说明=============
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#
#    ftBranchNameResolution -h
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #依赖校验
    [[ -z $(which git) ]] && ftBranchNameResolution --rely "git" && return
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ];then
        ftBranchNameResolution --env
        return
    fi
    local valCount=0 errorContent

    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBranchNameResolution -h && return

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local key="branchName="
    local filePathGitConfigInfoLocal=${dirPathOut}/git.info
    if [ -f "$filePathGitConfigInfoLocal" ];then
        local bn=$(cat $filePathGitConfigInfoLocal|grep "$key")
        if [[ -n "$bn" ]];then
            local branchNameFile=${bn//$key/}
            if [[ "$branchNameFile" != "$branchName" ]]; then
                    ftEcho -e "环境与本地，分支不一致:\n本地:$branchNameFile\n环境:$branchName"
            fi
            branchName=$branchNameFile
        else
            echo "${key}${branchName}" >>$filePathGitConfigInfoLocal
        fi
    elif [ -d "$dirPathOut" ];then
        echo "${key}${branchName}" >$filePathGitConfigInfoLocal
    fi
    if [[ -n "$branchName" ]];then
        local OLD_IFS="$IFS"
        IFS=")"
        local arrayItems=($branchName)
        IFS="$OLD_IFS"
        export AutoEnv_branchName=$branchName
        if [ "$branchName" = "$arrayItems" ];then
                ftEcho -e "分支名:${branchName} 不合法\n分支信息解析失败"
        else
                export AutoEnv_clientName=
                export AutoEnv_projrctName=
                export AutoEnv_modelAllName=
                export AutoEnv_demandSignName=
                export AutoEnv_motherboardName=
                export AutoEnv_screenScanDirection=
                export AutoEnv_BandInfo=
                export AutoEnv_FlashConfig=
                export AutoEnv_branchName=null

                for item in ${arrayItems[@]} ; do
                        local key=${item%\(*}
                        local val=${item//$key/}
                        val=${val//\(/}
                        key=${key//_/}

                         [[ $key = "CT" ]] && export AutoEnv_clientName=$val && continue
                         [[ $key = "PJ" ]] && export AutoEnv_projrctName=$val && continue
                         [[ $key = "SS" ]] && export AutoEnv_screenScanDirection=$val && continue
                         [[ $key = "DM" ]] && export AutoEnv_demandSignName=$val && continue
                         [[ $key = "PMA" ]] && export AutoEnv_modelAllName=$val && continue
                         [[ $key = "MBML" ]] && export AutoEnv_motherboardName=$val && continue
                         [[ $key = "BAND" ]] && export AutoEnv_BandInfo=$val && continue
                         [[ $key = "FLASH" ]] && export AutoEnv_FlashConfig=$val && continue
                done
                [[ -n "$branchName" ]] && export AutoEnv_branchName=$branchName
        fi
    fi
    cd $dirPathLocal
}

complete -W "-h --help" ftBuildPropResolution
ftBuildPropResolution()
{
    local ftEffect=build.prop解析
    local isEnable=true

    while true; do case "$1" in
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的依赖说明=============
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#
#    ftBuildPropResolution -h
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #依赖校验
    [[ -z $(which git) ]] && ftBuildPropResolution --rely "git" && return
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ];then
        ftBuildPropResolution --env
        return
    fi
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBuildPropResolution -h && return

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    local keySoftType="ro.build.type=" keyModel="ro.product.model=" keySoftVersion="ro.build.display.id="
    local keySDKVersion="ro.build.version.sdk=" filePathSystemBuildprop=${dirPathOut}/system/build.prop
    local deviceModelName deviceSoftType deviceSoftVersion deviceSdkVersion

    export AutoEnv_deviceModelName=
    export AutoEnv_deviceSoftType=
    export AutoEnv_deviceSoftVersion=
    export AutoEnv_deviceSdkVersion=
    export AutoEnv_AndroidVersion=

    if [ -f "$filePathSystemBuildprop" ];then
            deviceModelName=$(cat $filePathSystemBuildprop|grep "$keyModel")
            deviceSoftType=$(cat $filePathSystemBuildprop|grep "$keySoftType")
            deviceSoftVersion=$(cat $filePathSystemBuildprop|grep "$keySoftVersion")
            deviceSdkVersion=$(cat $filePathSystemBuildprop|grep "$keySDKVersion")
    elif [ "$editType" = "-bp" ];then
            ftEcho -s "未找到 $filePathSystemBuildprop\n版本软件信息未获取"
            return
    fi

    if [[ -n "$deviceSoftVersion" ]];then
            deviceModelName=${deviceModelName//$keyModel/}
            deviceModelName=${deviceModelName// /_}
            deviceModelName=$(echo $deviceModelName |sed s/[[:space:]]//g)
            deviceModelName=${deviceModelName:-'null'}
            export AutoEnv_deviceModelName=$deviceModelName

            deviceSoftType=${deviceSoftType//$keySoftType/}
            deviceSoftType=$(echo $deviceSoftType |sed s/[[:space:]]//g)
            deviceSoftType=${deviceSoftType:-'null'}
            export AutoEnv_deviceSoftType=$deviceSoftType

            deviceSoftVersion=${deviceSoftVersion//$keySoftVersion/}
            deviceSoftVersion=$(echo $deviceSoftVersion |sed s/[[:space:]]//g)
            deviceSoftVersion=${deviceSoftVersion:-'null'}
            export AutoEnv_deviceSoftVersion=$deviceSoftVersion

            deviceSdkVersion=${deviceSdkVersion//$keySDKVersion/}
            deviceSdkVersion=$(echo $deviceSdkVersion |sed s/[[:space:]]//g)
            deviceSdkVersion=${deviceSdkVersion:-'null'}
            export AutoEnv_deviceSdkVersion=$deviceSdkVersion
            local AndroidVersion=$(ftIniGetValue $rFilePathXbashDataBase androidSDK2Verison $deviceSdkVersion)
            export AutoEnv_AndroidVersion=$AndroidVersion
    fi

    cd $dirPathLocal
}

complete -W "-b -h" ftAutoBuildMultiBranchEnvSeparation
ftAutoBuildMultiBranchEnvSeparation()
{
    local ftEffect=多分支串行编译[环境独立]/在多个终端间串行执行命令
    local isEnable=true

    while true; do case "$editType" in
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    查看帮助
#    ftAutoBuildMultiBranchEnvSeparation -h
#
#    根据分支列表进行串行编译
#    ftAutoBuildMultiBranchEnvSeparation -b
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
    [ -z "$ANDROID_BUILD_TOP" ] && ftAutoBuildMultiBranchEnvSeparation --env && return
    #解参验耦
    local editType=${1,,}
    local filePathserialBuildTool=${rDirPathXbashModuleAuto}/serialBuildByBranchName.module
    local dirPathProcessEnableId=/tmp/ProcessEnableIds
    local requestEnvState=$(/bin/rm -rf $dirPathProcessEnableId&&mkdir $dirPathProcessEnableId)
    local valCount=1 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$editType" ] && errorContent="${errorContent}\\n[请指定操作]"
    [[ -n "$requestEnvState" ]] && errorContent="${errorContent}\\n[环境初始化异常,文件夹无法重置]requestEnvState=$requestEnvState" 
    [ ! -f "$filePathserialBuildTool" ] && errorContent="${errorContent}\\n[串行编译工具不存在]filePathserialBuildTool=$filePathserialBuildTool"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoBuildMultiBranchEnvSeparation -h && return

    #实现主体
    if [[ "$editType" = "-b" ]]; then
        local dirPathCode=$ANDROID_BUILD_TOP
        local filePathBranchList=${dirPathProcessEnableId}/branch.list
        cd $dirPathCode

        if [[ -n "$(pgrep -f gedit)" ]];then
                while true; do echo && ftEcho -y gedit 已打开是否关闭
                read -n 1 sel
                case "$sel" in
                    y | Y )    kill -9 $(ps -e|grep gedit |awk '{print $1}') ; break;;
                    n | N |q | Q)    return;;
                    * ) ftEcho -e 错误的选择：$sel && echo "输入n,q，离开" ; ;;
                esac ; done
        fi
        git branch > $filePathBranchList && gedit $filePathBranchList && while [[ -n "$(pgrep -f gedit)" ]] ; do echo 等待中 ;sleep 1 ;done

        local branchArray=($(cat $filePathBranchList))
        if [[ -n "$branchArray" ]];then
                    export branchArray=(${branchArray[@]})
                    echo enable>${dirPathProcessEnableId}/0
                    for (( index = 0; index <${#branchArray[@]}; index++ )); do
                        filePathState="${dirPathProcessEnableId}/${index}"
                        while [ ! -f "$filePathState" ]||[ "enable" != $(cat $filePathState) ]; do sleep 10 ;done
                        gnome-terminal  --title="任务:${index} : 编译${branchArray[$fileNamePID]}" -x bash -c "$filePathserialBuildTool $index $filePathBranchList"
                    done
        fi
    fi
}

ftAutoBackupOrRestoreOuts()
{
    local ftEffect=Android编译生成out相关自动维护
    local isEnable=true

    while true; do case "$1" in
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    备份out
#    ftAutoBackupOrRestoreOuts 无参
#    ftAutoBackupOrRestoreOuts -t 备注
#
#    移动匹配out到当前项目
#    ftAutoBackupOrRestoreOuts -m
#    ftAutoBackupOrRestoreOuts -m xxx   #分支名包含xxx的out列表
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    ftAutoInitEnv
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    local arg arg2 index errorContent 
    local isMoveBack mTagContent filterString
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; ((index=i+1)) ; eval arg2=\${${index}} ; case "${arg}" in
        -t ) mTagContent="${arg2}"
             ;;
        -m )  isMoveBack=true
                filterString="${arg2}"
             ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    if [ ! -d "$dirPathCode" ]||[  -z "$dirPathCode" ];then
        errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    fi
    if [ -z "$ANDROID_BUILD_TOP" ]||[ -z "$ANDROID_PRODUCT_OUT" ];then
        if [[ -f "ftAutoBackupOrRestoreOuts" ]];then
            ./ftAutoBackupOrRestoreOuts $@
            return
        fi
        ftAutoBackupOrRestoreOuts --env && return
    fi
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoBackupOrRestoreOuts -h && return

    #实现主体
    cd $dirPathCode
    #分支名
    local buildType=$AutoEnv_buildType versionName=$AutoEnv_versionName branchName="$AutoEnv_branchName"

    local dirNameCodeRootOuts=outs
    local dirPathOutTop=${dirPathCode}/out
    local dirPathCodeRootOuts=${dirPathCode%/*}/${dirNameCodeRootOuts}
    local versionInfoDateTime=$(date -d "today" +"%y%m%d[%H:%M]")
    local dirNameBranchVersion=BuildType[${buildType}]----BranchName[${branchName}]----VersionName[${versionName}]----${versionInfoDateTime}
    [[ -n "$mTagContent" ]]&&dirNameBranchVersion=${dirNameBranchVersion}_Tag[${mTagContent}]
    local dirPathOutBranchVersion=${dirPathCodeRootOuts}/${dirNameBranchVersion}

    if [ ! -d "$dirPathCodeRootOuts" ];then
        [[ -n "$isMoveBack" ]] && ftEcho -e "${dirNameCodeRootOuts}为空" && return
        mkdir -p $dirPathCodeRootOuts
    fi

    if [[ -n "$isMoveBack" ]]; then
        if [[ -d "$dirPathOut" ]]||[[ -d "$dirPathOutTop" ]]; then
            #lunch生成的out，视为无效
            local excludeConfigInfo=($(ftIniGetValue $rFilePathXbashDataBase backupOrRestoreOutsInfo excludeConfig))
            local excludeConfigSize=${#excludeConfigInfo[@]}
            local dirPathOutTopInfo=($(ls $dirPathOutTop))
            local dirPathOutTopSize=${#dirPathOutTopInfo[@]}
            for item in ${excludeConfigInfo[@]} ; do
                    item=${dirPathOutTop}/${item}
                    [[ ! -d "$item" ]]&&[[ ! -f "$item" ]] && excludeConfigSize=0 && break
            done
            if (( $excludeConfigSize == $dirPathOutTopSize )); then
                rm -rf $dirPathOutTop
            else
                ftEcho -e "out已存在 ,请先备份"
                return
            fi
        fi

        [[ -n "$filterString" ]] && branchName=$filterString
        local dirPathOutList=($(ls $dirPathCodeRootOuts|grep $branchName))
        [[ -z "$dirPathOutList" ]] && ftEcho -e "未找到\n分支[$branchName]对应的out" && return

        local itemCount=${#dirPathOutList[@]}
        local dirNameOutTraget=$dirPathOutList
        if (( $itemCount>1 ));then
            ftEcho -s 对应分支对应多个out,请选择
            local index=0
            for item in ${dirPathOutList[@]} ; do
                printf "%-4s %-4s\n" [$index] $item
                ((index+=1))
            done

            local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
            ftEcho -r  "请输入对应的序号(回车默认0):"
            read -n $length tIndex &&echo
            #设定默认值
            [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
            (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return
            dirNameOutTraget=${dirPathOutList[$tIndex]}
        fi
        mv ${dirPathCodeRootOuts}/${dirNameOutTraget} $dirPathOutTop&&
        ftEcho -s "移动 ${dirPathCodeRootOuts}/${dirNameOutTraget}\n 到  ${dirPathOutTop}"
        return
    fi

    if [ ! -d "$dirPathOutBranchVersion" ];then
        [[ ! -d "$dirPathOutTop" ]] && ftEcho -e "out 不存在" && return
        if [[ ! -d "$dirPathOut" ]]; then
             ftEcho -e "out 不完整"
             dirNameBranchVersion=${dirNameBranchVersion}____section
        fi

        local fileNameGitLogInfo=git.log
        local filePathGitLogInfo=${dirPathOutTop}/${fileNameGitLogInfo}
        [[ ! -f $filePathGitLogInfo ]] && touch $filePathGitLogInfo
        echo -e "

======================================================================================================
$dirNameBranchVersion
======================================================================================================
$(ftGitLogShell  -n 20 -c "%h  %s")" >> $filePathGitLogInfo
        mv ${dirPathOutTop}/ $dirPathOutBranchVersion&&
        ftEcho -s "移动 $dirPathOutTop \n到  ${dirPathCodeRootOuts}/${dirNameBranchVersion}"
    else
        ftEcho -ex 存在相同out
    fi
}

ftAutoUpload()
{
    local ftEffect=文件[夹]上传
    local isEnable=true

    while true; do case "$1" in
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
#    依赖缺失,请使用下面命令安装
#    sudo add-apt-repository ppa:pi-rho/security&&sudo apt-get update
#    sudo apt-get install sshpass pigz pv nmap
#=========================================================" ;return;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    ftAutoUpload 源存放目录 服务器地址
#
#    ftAutoUpload xxx 192.168.xxx.xxx
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
     [[ -z $(which nmap) ]]|| [[ -z $(which sshpass) ]]|| [[ -z $(which pigz) ]]|| [[ -z $(which pv) ]] && ftAutoUpload --rely && return
    #解参验耦
    local dirPathContentUploadSource=$1 serverIp=$2
    local valCount=2 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathContentUploadSource" ] && errorContent="${errorContent}\\n上传源存放目录不存在:dirPathContentUploadSource=$dirPathContentUploadSource"
    if [ -z "$serverIp" ];then
        errorContent="${errorContent}\\n 这个东西送到哪都没说:serverIp=$serverIp"
    else
        if [ "$serverIp" = "$(/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6 |grep 192.168.|awk '{print $2}'|tr -d "addr:" |tr -d "地址")" ];then
            errorContent="${errorContent}\\n 目标服务器指向本机，请确认配置:serverIp=$serverIp"
        else
            local tagName=serverConfig_${serverIp}
            local userName=$(ftIniGetValue $rFilePathXbashDataBase $tagName userName)
            local userPassword=$(ftIniGetValue $rFilePathXbashDataBase $tagName userPassword)
            local dirPathPackage=$(ftIniGetValue $rFilePathXbashDataBase $tagName dirPathPackage)

            [ -z "$userName" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]用户名获取失败"
            [ -z "$userPassword" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]密码获取失败"
            [ -z "$dirPathPackage" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]目标路径获取失败"
        fi
    fi
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoUpload -h && return

    #实现主体

    ftEcho -s "\n========================\n开始上传文件:\n  ${dirPathContentUploadSource}\n服务器路径:\n  ${serverIp}$dirPathPackage\n========================\n"

    local serverProtInfo="$(nmap $serverIp)"
    if [[ -z $(echo ${serverProtInfo[@]}|grep ssh) ]]&&[[ -n $(echo ${serverProtInfo[@]}|grep 445) ]]; then #使用smb协议
        local dirPathServerLocalBase=$(ftIniGetValue $rFilePathXbashDataBase $tagName dirPathPackageLocal)
        if ! mountpoint -q $dirPathServerLocalBase; then
            ftEcho -e "当前目录未挂载服务器共享目录:\n${dirPathUploadLocal}" && return
        else
            local key="智能机软件"
            cp -r -b -S _old -v $key $(echo $dirPathServerLocalBase | sed -e "s:/$key::g")
        fi
    else #使用ssh协议
        # 自动添加旧软件的TAG
        local dirPathServerLocalBase=$(ftIniGetValue $rFilePathXbashDataBase $tagName dirPathPackageLocal)
        if [[ -n "$dirPathServerLocalBase" ]]; then
            local dirPathServerLocal=${dirPathServerLocalBase}/${dirPathContentUploadSource}
            if [[ -d $dirPathServerLocal ]]&&[[ -n "$ANDROID_BUILD_TOP" ]]; then
                    local versionPath=$(dirname $dirPathServerLocal)
                    local versionName=$(basename $dirPathServerLocal)

                    ls $versionPath | while read line;do
                        if [[  ${line//$versionName} != $line ]]; then
                            local dirPath=${versionPath}/${line}
                            local dirPath_old=${dirPath}_old
                            [[ -d "$dirPath_old" ]] && dirPath_old=${dirPath_old}_old
                            mv $dirPath $dirPath_old
                        fi
                    done
            fi
        fi
        local packageSize=$(du -sk $dirPathContentUploadSource | cut -f1)k
        tar -cv  ${dirPathContentUploadSource%%/*}| pv --size $packageSize -p --timer --rate --bytes| pigz -1|sshpass -p $userPassword ssh $userName@$serverIp "gzip -d |tar -xPC $dirPathPackage"
    fi

    ftEcho -s "上传结束"
}

complete -W "-a" ftAutoPacket
ftAutoPacket()
{
    local ftEffect=基于android的out生成版本软件包
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftClearTail $dirPathLocal ; echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    ftAutoPacket -y #免确认自动清理out/packet
#    ftAutoPacket -u #上传到188服务器
#    ftAutoPacket -r #添加说明
#    ftAutoPacket -p #打包
#    ftAutoPacket -a #默认启动全部流程
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;; esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    ftAutoInitEnv
    if [ -z "$ANDROID_BUILD_TOP" ]\
            ||[ -z "$TARGET_PRODUCT" ]\
            ||[ -z "$ANDROID_PRODUCT_OUT" ]\
            ||[ -z "$TARGET_BUILD_VARIANT" ];then
        if [[ -f "ftAutoPacket" ]];then
            ./ftAutoPacket
            return
        fi
        ftAutoPacket --env
        return
    fi
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT buildType=$TARGET_BUILD_VARIANT
    local editType=$1 filePathDataBase=$rFilePathXbashDataBase
    local valCount=1 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ ! -d "$dirPathOut" ] && errorContent="${errorContent}\\n[工程out目录不存在]dirPathOut=$dirPathOut"
    [ ! -f "$filePathDataBase" ] && errorContent="${errorContent}\\n[数据库文件不存在]filePathDataBase=$filePathDataBase"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoPacket -h && return

    #实现主体
    local isClean isReadMe isUpload isPacket isMove isCopy isSpecial
    local arg arg2 index ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; ((index=i+1)) ; eval arg2=\${${index}} ; case "${arg}" in
        -a ) isClean=true
              isReadMe=true
              isUpload=true
              isPacket=true ;;
        -y ) isClean=true ;;
        -m ) isMove=true ;;
        -u ) isUpload=true ;;
        -r ) isReadMe=true ;;
        -p ) isPacket=true 
               isReadMe=true ;;
        -c ) isCopy=true ;;
        -t ) isSpecial=true
            isPacket=true ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    local dirPathLocal=$dirPathCode dirNameVersionSoftware=packet buildType=$AutoEnv_buildType
    local dirPathVersionSoftware=${dirPathCode}/out/${dirNameVersionSoftware}

    if [[ -d "$dirPathVersionSoftware" ]]; then
            if [[ -n "$isClean" ]]; then
                rm  -rf $dirPathVersionSoftware
                ftEcho -s "删除旧的软件包"
            elif [[ -n "$isMove" ]]; then
                mv $dirPathVersionSoftware ${dirPathVersionSoftware}_old
                ftEcho -s "发现软件包,移至xx_old"
            elif [[ -z "$isUpload" ]]; then
                  while true; do
                        ftEcho -y "有旧的软件包  ${dirPathVersionSoftware}\n是否删除"
                        read -n 1 sel
                        case "$sel" in
                            y | Y ) rm  -rf $dirPathVersionSoftware
                                       break;;
                            n | q )    break ;;
                            * ) ftEcho -e 错误的选择：$sel
                                echo "输入n，q，离开";;
                        esac
                done
                echo
            fi
    fi

    [[ ! -d "$dirPathVersionSoftware" ]] && mkdir $dirPathVersionSoftware
    cd $dirPathVersionSoftware && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    if [[ $AutoEnv_mnufacturers = "sprd" ]]; then
            if [ "$TARGET_PRODUCT" != "sp7731c_1h10_32v4_oversea" ];then
                ftEcho -ea " ${ftEffect} 缺少平台${AutoEnv_mnufacturers}的项目${TARGET_PRODUCT}的配置\
                \n请查看下面说明:"
                ftAutoPacket -h
                return
            fi
            local dirPathNormalBin=$dirPathOut
            local dirPathLogo=${dirPathCode%/*}/res
            local versionName=$AutoEnv_versionName
            local dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${versionName}
            local dirPathModemBin=${dirPathCode%/*}/res/packet_modem
            local softwareVersion=MocorDroid6.0_Trunk_16b_rls1_W16.29.2
            local filePathPacketScript=${rDirPathXbashModuleAuto}/packet_7731c.module

            [[ -n "$(cat $versionName|grep 451)" ]] && dirPathModemBin=${dirPathModemBin}2

            if [ ! -f "$filePathPacketScript" ];then
                    ftEcho -ea "[${ftEffect}]的参数错误 \
                       找不到 [sprd的打包工具]filePathPacketScript=$filePathPacketScript \
                        请查看下面说明:"
                    ftAutoPacket -h
                    return
            fi

            [[ -n "$buildType" ]]&&[ $buildType != "user" ] && versionName=${versionName}____${buildType}

            local dirPathVersionSoftwareLocal="智能机软件"
            local tagName="lzProjrctConfigBranch2CtName"
            local clientNameAll=$(ftIniGetValue $filePathDataBase $tagName $AutoEnv_clientName)
            tagName="lzProjrctConfigBranch2PlatformName"
            local platformName=$(ftIniGetValue $filePathDataBase $tagName $TARGET_PRODUCT)
            if [[ -n "$platformName" ]];then
                 dirPathVersionSoftwareLocal=${dirPathVersionSoftwareLocal}/${platformName}/${clientNameAll:-'autoUpload'}/${versionName}
            else
                 dirPathVersionSoftwareLocal=${dirPathVersionSoftwareLocal}/autoUpload/${versionName}
            fi

            dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${dirPathVersionSoftwareLocal}
            mkdir -p $dirPathVersionSoftwareVersion

            # 生成软件包
            if [[ -n "$isPacket" ]]; then
                   ftEcho -s "开始生成 ${versionName}.pac\n"
                    cd $dirPathVersionSoftwareVersion  && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

                    /usr/bin/perl $filePathPacketScript \
                        $versionName.pac \
                        SC77xx \
                        ${versionName}\
                        ${dirPathNormalBin}/SC7720_UMS.xml \
                        ${dirPathNormalBin}/fdl1.bin \
                        ${dirPathNormalBin}/fdl2.bin \
                        ${dirPathModemBin}/nvitem.bin \
                        ${dirPathModemBin}/nvitem_wcn.bin \
                        ${dirPathNormalBin}/prodnv.img \
                        ${dirPathNormalBin}/u-boot-spl-16k.bin \
                        ${dirPathModemBin}/SC7702_pike_modem_AndroidM.dat \
                        ${dirPathModemBin}/DSP_DM_G2.bin \
                        ${dirPathModemBin}/SC8800G_pike_wcn_dts_modem.bin \
                        ${dirPathNormalBin}/boot.img \
                        ${dirPathNormalBin}/recovery.img \
                        ${dirPathNormalBin}/system.img \
                        ${dirPathNormalBin}/userdata.img \
                        ${dirPathLogo}/logo.bmp \
                        ${dirPathNormalBin}/cache.img \
                        ${dirPathNormalBin}/sysinfo.img \
                        ${dirPathNormalBin}/u-boot.bin \
                        ${dirPathNormalBin}/persist.img&&
                    ftEcho -s 生成7731c使用的pac[${dirPathVersionSoftwareVersion}/${versionName}.pac]
                    cd $dirPathLocal && dirPathLocal=
            fi

            # 生成说明文件
            [[ -n "$isReadMe" ]] && ftAutoCreateReadMeBySoftwareVersion $dirPathVersionSoftwareVersion

            #上传服务器
            [[ -n "$isUpload" ]] && ftAutoUpload $dirPathVersionSoftwareLocal 192.168.1.75

    elif [[ $AutoEnv_mnufacturers = "mtk" ]]; then
            local dirNamePackage="packages" dirNameOtaPackage="otaPackages" dirNamePackageDataBase="dataBase"
            local deviceName=$(basename $ANDROID_PRODUCT_OUT) dataBaseFileList

            if [ $deviceName = "m9_xinhaufei_r9_hd" ];then
                tagName="lzProjrctConfigSoftwareDataBaseFileLIst"
                dataBaseFileList=($(ftIniGetValue $filePathDataBase $tagName $TARGET_PRODUCT))
            elif [ $deviceName = "keytak6580_weg_l" ];then
                # local dirNameModems=$(ls ${dirPathOut}/obj/ETC/BPLGUInfoCustomAppSrcP_*|grep ":")
                local dirPathDatabaseBpBase=${dirPathOut}/obj/ETC
                local dirNameModems=$(ls ${dirPathDatabaseBpBase}/|grep "BPLGUInfoCustomAppSrcP_")
                for dirName in ${dirNameModems[@]} ; do
                    dirName=${dirName//:/}
                    local dirPath=${dirPathDatabaseBpBase}/${dirName}
                    for fileName in $(ls $dirPath) ; do
                        local filePath=${dirPath}/${fileName}
                        if [[ ! -f "$filePath" ]]; then
                            ftEcho -e "文件${filePath}不存在"
                        else
                            dataBaseFileList=(${dataBaseFileList[@]} $filePath)
                        fi
                    done
                done
                dataBaseFileList=(${dataBaseFileList[@]} ${dirPathOut}/obj/CGEN/APDB_MT6580_S01_L1.MP6_W16.15)
            elif [ $deviceName = "m9_qhd" ];then
                tagName="lzProjrctConfigSoftwareDataBaseFileLIst"
                dataBaseFileList=($(ftIniGetValue $filePathDataBase $tagName $TARGET_PRODUCT))
            fi

            # system.img文件最新修改时间
            if [[ -f "${dirPathOut}/system.img" ]]; then
                    local key="最近更改："
                    local fileChangeTime=$(stat ${dirPathOut}/system.img|grep $key|awk '{print $1}'|sed s/-//g)
                    fileChangeTime=${fileChangeTime//$key/}
                    fileChangeTime=${fileChangeTime:-$(date -d "today" +"%y%m%d")}
            fi

            if [[ -n "$AutoEnv_clientName" ]];then #解析git分支,初始化客户等相关信息
                ftBuildPropResolution

                local dirPathGitBranchInfoGroup dirPathVersionSoftwareVersion 
                #版本路径 服务器根路径部分
                local dirPathUploadTraget=智能机软件 tagName="lzProjrctConfigBranch2CtName"
                local clientNameAll=$(ftIniGetValue $filePathDataBase $tagName $AutoEnv_clientName)
                tagName="lzProjrctConfigBranch2PlatformName"
                local platformName=$(ftIniGetValue $filePathDataBase $tagName $TARGET_PRODUCT)
                if [[ -n "$platformName" ]];then
                     dirPathUploadTraget=${dirPathUploadTraget}/${platformName}/${clientNameAll:-'autoUpload'}
                else
                     dirPathUploadTraget=${dirPathUploadTraget}/autoUpload
                fi


                if [[ -z "$dirPathUploadTraget" ]]; then
                    ftEcho -e "分支信息解析结果为空,请查看配置"
                    ftClearTail $dirPathLocal
                    return
                else
                    dirPathVersionSoftwareVersion=${dirPathUploadTraget}
                fi

                #版本路径 分支信息部分
                [[ -n "$AutoEnv_motherboardName" ]] && dirPathGitBranchInfoGroup=${AutoEnv_motherboardName}
                [[ -n "$AutoEnv_projrctName" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/${AutoEnv_projrctName}
                [[ -n "$AutoEnv_demandSignName" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/${AutoEnv_demandSignName}

                if [[ -n "$AutoEnv_deviceModelName" ]]; then
                    dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/${AutoEnv_deviceModelName}

                    [[ -n "$AutoEnv_BandInfo" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}_B${AutoEnv_BandInfo} #添加 modem 配置信息
                    [[ -n "$AutoEnv_FlashConfig" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}_${AutoEnv_FlashConfig} #添加 flash信息

                else
                    [[ -n "$AutoEnv_BandInfo" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/B${AutoEnv_BandInfo} #添加 modem 配置信息
                    [[ -n "$AutoEnv_FlashConfig" ]] && dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/${AutoEnv_FlashConfig} #添加 flash信息
                fi
                # if  [[ -n "$AutoEnv_AndroidVersion" ]&&(($AutoEnv_deviceSdkVersion>22)); then
                #         dirPathGitBranchInfoGroup=${dirPathGitBranchInfoGroup}/${AutoEnv_AndroidVersion}
                # fi
                [[ -z "$dirPathGitBranchInfoGroup" ]] && ftEcho -e "分支信息解析结果为空,请查看配置" && ftClearTail $dirPathLocal && return
                dirPathVersionSoftwareVersion=${dirPathVersionSoftwareVersion}/${dirPathGitBranchInfoGroup}

                local dirNameVeriosionBase=${AutoEnv_versionName}
                #非user版本标记编译类型
                [ "$AutoEnv_buildType" != "user" ] && dirNameVeriosionBase=${buildType}____${dirNameVeriosionBase}
                #软件版本的日期与当前时间不一致就设定编译时间
                arr=(${AutoEnv_versionName//_/ })
                length=${#arr[@]}
                ((length-=1))
                local versionNameDate=${arr[$length]}
                [[ $versionNameDate =~ "." ]] && versionNameDate=${versionNameDate%.*}
                if [[ -n "$fileChangeTime" ]]&&[ "$versionNameDate" != "${fileChangeTime}" ];then
                    export AutoEnv_SoftwareVersion_BuildTime=buildtime____${fileChangeTime}
                     dirNameVeriosionBase=${dirNameVeriosionBase}____${AutoEnv_SoftwareVersion_BuildTime}
                fi

                if [[ -n "$isSpecial" ]]; then
                    ftEcho -r $"请输入版本: "${dirNameVeriosionBase}"\n相应的说明[回车默认为常规]:"
                    read tag
                    tag=${tag:-'常规'}
                    dirNameVeriosionBase=${tag}____${dirNameVeriosionBase}
                fi
                dirPathVersionSoftwareVersion=${dirPathVersionSoftwareVersion}/${dirNameVeriosionBase}

            else
                if [[ -n "$fileChangeTime" ]];then
                    local dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${fileChangeTime}____buildType[${buildType}]__versionName[${AutoEnv_versionName}]__$fileChangeTime
                else
                    local dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/buildType[${buildType}]__versionName[${AutoEnv_versionName}]
                fi
            fi

            [[ -n "AutoEnv_motherboardName" ]] && dirPathUploadTraget=${dirPathUploadTraget}/${AutoEnv_motherboardName}
            local dirPathPackage=${dirPathVersionSoftwareVersion}/${dirNamePackage}
            local dirPathOtaPackage=${dirPathVersionSoftwareVersion}/${dirNameOtaPackage}
            local dirPathPackageDataBase=${dirPathVersionSoftwareVersion}/${dirNamePackageDataBase}
            local dirPathOta=${dirPathOut}/obj/PACKAGING/target_files_intermediates
            if [[ -d "$dirPathOta" ]]; then
                local otaFileList=$(ls ${dirPathOta}/${TARGET_PRODUCT}-target_files-* |grep .zip)
            else
                ftEcho -e "OTA相关包未找到"
            fi

            # 生成本地软件包
            if [[ -n "$isPacket" ]]; then
                    mkdir -p $dirPathVersionSoftwareVersion

                    ftEcho -s "\n========================\n开始生成版本软件包:\n  ${dirNameVeriosionBase}\n路径:\n  ${dirPathVersionSoftwareVersion}\n========================\n"
                    #packages
                    filePathSystemImage=${dirPathOut}/system.img
                    if [[ -f "$filePathSystemImage" ]]; then
                        mkdir -p $dirPathPackage
                        # packages需要的文件列表
                        tagName="lzProjrctConfigSoftwarePackageFileLIst"
                        local fileList=($(ftIniGetValue $filePathDataBase $tagName ${TARGET_PRODUCT}))
                        for file in ${fileList[@]}; do
                            local filePath=${dirPathOut}/${file}
                            [[ ! -f "$filePath" ]] && ftEcho -e "找不到 : ${filePath}" && ftClearTail $dirPathLocal && return

                             printf "%-2s %-30s\n" 复制 $file
                             cp -r -f  $filePath $dirPathPackage
                             # rsync --progress  $filePath $dirPathPackage
                             # printf "\033[0;32;36m 复制 $file\n\033[0m"
                             # pv $filePath > ${dirPathPackage}/${file}
                        done
                    else
                        ftEcho -e "软件包不完整,请确认\n不存在  $filePathSystemImage" && ftClearTail $dirPathLocal && return
                    fi
                    #otaPackages
                    if [[ -n "$otaFileList" ]]; then
                        mkdir -p $dirPathOtaPackage
                        for file in ${otaFileList[@]}; do
                             [[ ! -f "$file" ]] && ftEcho -e "找不到 : ${file}" && ftClearTail $dirPathLocal && return

                             printf "%-2s %-30s\n" 复制 $(echo $file | sed "s ${dirPathOut}/  ")
                             cp -r -f  $file $dirPathOtaPackage
                        done
                    fi
                    # database
                    if [[ -n "$dataBaseFileList" ]];then
                        mkdir -p $dirPathPackageDataBase
                        for filePath in ${dataBaseFileList[@]}; do
                             [[ ! -f "$filePath" ]] && filePath=${dirPathOut}/${filePath}
                             [[ ! -f "$filePath" ]] &&  ftEcho -e "找不到 : ${filePath}" && continue

                            fileName=$(basename $filePath)
                            printf "%-2s %-30s\n" 复制 $(echo $fileName | sed "s ${dirPathOut}  ")
                             cp -r -f  $filePath $dirPathPackageDataBase
                        done
                    fi
            fi

            # 生成说明文件
            [[ -n "$isReadMe" ]] && ftAutoCreateReadMeBySoftwareVersion ${dirPathVersionSoftware}/${dirPathVersionSoftwareVersion}

            #上传服务器
            [[ -n "$isUpload" ]] && ftAutoUpload $dirPathVersionSoftwareVersion 192.168.1.75
    else
            ftEcho -ea "${ftEffect} 没有平台${AutoEnv_mnufacturers}的配置\n请查看下面说明:"
            ftAutoPacket -h
            return
    fi
    cd $dirPathLocal
    trap SIGINT
}

ftAutoCreateReadMeBySoftwareVersion()
{
    local ftEffect=创建软件版本相关修改记录和版本说明
    local isEnable=true

    while true; do case "$1" in
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    ftAutoCreateReadMeBySoftwareVersion [dir_path_pac_res] #生成7731c使用的pac的目录，和生成所需的文件存放的目录
#    ftAutoCreateReadMeBySoftwareVersion out/pac
#========================================================="; return ;;
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftAutoCreateReadMeBySoftwareVersion --rely && return
    #解参验耦
    ftAutoInitEnv
    [ -z "$ANDROID_BUILD_TOP" ]||[ -z "$ANDROID_PRODUCT_OUT" ] && ftAutoCreateReadMeBySoftwareVersion --env && return
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT dirPathVersionSoftware=$1
    local filePathConfig=$rFilePathXbashDataBase
    [[ -z "$dirPathVersionSoftware" ]]&&dirPathVersionSoftware=${dirPathOut}/${AutoEnv_versionName}
    dirPathVersionSoftware=$(ftPath $dirPathVersionSoftware)
    local valCount=1 errorContent
    #(( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ ! -d "$dirPathOut" ] && errorContent="${errorContent}\\n[工程out目录不存在]dirPathOut=$dirPathOut"
    [ ! -f "$filePathConfig" ] && errorContent="${errorContent}\\n[工程out目录不存在]filePathConfig=$filePathConfig"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoCreateReadMeBySoftwareVersion -h && return

    #实现主体
    local dirPathLocal=${PWD} fileNameReadMeTemplate=客户说明.txt fileNameChangeListTemplate=版本说明.txt
    local filePathReadMeTemplate=${dirPathVersionSoftware}/${fileNameReadMeTemplate}
    local filePathChangeListTemplate=${dirPathVersionSoftware}/${fileNameChangeListTemplate}
    local versionName=$AutoEnv_versionName

    [ ! -d "$dirPathVersionSoftware" ] && mkdir $dirPathVersionSoftware
    cd $dirPathCode && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    #使用git 记录的修改记录
    local gitCommitListOneDay=$(ftGitLogShell -t "%h %s" -n 30) gitCommitListBefore=$(ftGitLogShell -t "%h %s" -n 30)

# ===============================================
# =================     修改记录    ==================
# ===============================================
    if [ $AutoEnv_mnufacturers = "sprd" ];then
            # 暗码清单,动画切换暗码
            local filePathPawInfo=${dirPathCode}/packages/apps/Dialer/src/com/android/dialer/SpecialCharSequenceMgr.java
            if [ -f $filePathPawInfo ];then
                    local key="    private static final String PAW_NUM_INFO ="
                    local pawNumInfo=$(cat $filePathPawInfo|grep "$key")  #获取暗码清单信息
                    pawNumInfo=${pawNumInfo//$key/};
                    pawNumInfo=${pawNumInfo//\";/};
                    pawNumInfo=${pawNumInfo//\"/};
                    pawNumInfo=$(echo $pawNumInfo |sed s/[[:space:]]//g)

                    key="    private static final String LOGO_CHANGE ="
                    local changLogoNumInfo=$(cat $filePathPawInfo|grep "$key")  #动画切换暗码信息
                    changLogoNumInfo=${changLogoNumInfo//$key/};
                    changLogoNumInfo=${changLogoNumInfo//\";/};
                    changLogoNumInfo=${changLogoNumInfo//\"/};
                    changLogoNumInfo=$(echo $changLogoNumInfo |sed s/[[:space:]]//g)
            else
                    ftEcho -e "[工程暗码配置文件不存在:]\n$filePathPawInfo"
            fi

            #摄像头配置相关
            local filePathCameraConfig=${dirPathCode}/${AutoEnv_deviceDirPath}/BoardConfig.mk
            if [ -f $filePathCameraConfig ];then
                    local keyType="LZ_CONFIG_CAMERA_TYPE := "
                    local keySizeBack="CAMERA_SUPPORT_SIZE := "
                    local keySizeFront="FRONT_CAMERA_SUPPORT_SIZE := "

                    local cameraTypeInfo=$(cat $filePathCameraConfig|grep "$keyType")
                    local cameraSizeBackMax=$(cat $filePathCameraConfig|grep "$keySizeBack")
                    local cameraSizeFrontMax=$(cat $filePathCameraConfig|grep "$keySizeFront")

                    cameraTypeInfo=${cameraTypeInfo//$keyType/};
                    cameraSizeFrontMax=${cameraSizeFrontMax//$keySizeFront/};

                    cameraSizeBackMax=${cameraSizeBackMax//${keySizeFront}$cameraSizeFrontMax/};
                    cameraSizeBackMax=${cameraSizeBackMax//$keySizeBack/};

                    cameraTypeInfo=$(echo $cameraTypeInfo |sed s/[[:space:]]//g)
                    cameraSizeFrontMax=$(echo $cameraSizeFrontMax |sed s/[[:space:]]//g)
                    cameraSizeBackMax=$(echo $cameraSizeBackMax |sed s/[[:space:]]//g)

                    sizeFcameraList=(real 2M 5M 8M)
                    sizeBcameraList=(real 2M 5M 8M 12M)
                    local cameraSizeFrontDefault=${sizeFcameraList[LZ_FCAM]}
                    local cameraSizeBackDefault=${sizeBcameraList[LZ_BCAM]}
            else
                    ftEcho -e "[相机配置文件不存在，获取失败]\n$filePathCameraConfig"
            fi

            #修改记录头部
            local enterLine="\n"
            local content="当前版本：$versionName"${enterLine}
            content=${content}${enterLine}"说明：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
            content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
            content=${content}${enterLine}
            content=${content}${enterLine}"摄像头类型：$cameraTypeInfo"
            content=${content}${enterLine}"默认 前/后摄大小：$cameraSizeFrontDefault/$cameraSizeBackDefault"
            content=${content}${enterLine}"真实插值 前/后摄大小：$cameraSizeFrontMax/$cameraSizeBackMax"
            # content=${content}${enterLine}"默认 RAM/ROM：$sizeRam/$sizeRom"
            content=${content}${enterLine}
            content=${content}${enterLine}"暗码清单：$pawNumInfo"
            content=${content}${enterLine}"开关机动画暗码：$changLogoNumInfo"

            #git log 列表
            echo -e "﻿$gitCommitListBefore">$filePathChangeListTemplate
            seq 10 | awk '{printf("    %02d %s\n", NR, $0)}' $filePathChangeListTemplate >${filePathChangeListTemplate}.temp

            # 合并头部和git log 列表
            echo -e ${content}${enterLine}${enterLine}"修改记录："| cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate

            # 转化为windows下面文件格式
            unix2dos $filePathChangeListTemplate

   elif [[ $AutoEnv_mnufacturers = "mtk" ]]; then

            #修改记录头部
            local enterLine="\n"
            local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
            content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
            content=${content}${enterLine}
            content=${content}${enterLine}"当前版本：$versionName"
            content=${content}${enterLine}"基础版本："
            content=${content}${enterLine}
            content=${content}${enterLine}"修改记录："

            local filePathConfigHideNum=${dirPathCode}/vendor/lz/hideNum.config
            #if [[ "$TARGET_PRODUCT" = "full_m9_qhd" ]]&&[[ -f "$filePathConfigHideNum" ]]; then

                #content=${content}${enterLine}"暗码清单：$(ftIniGetValue $filePathConfigHideNum 暗码清单 info)"
                # content=${content}${enterLine}"隐藏指令：$(ftIniGetValue $filePathConfigHideNum 隐藏 info)"
                #content=${content}${enterLine}"工厂测试：$(ftIniGetValue $filePathConfigHideNum 工厂测试 info)"
                #content=${content}${enterLine}"imei编辑：$(ftIniGetValue $filePathConfigHideNum imei编辑 info)"
                #content=${content}${enterLine}"imei显示：$(ftIniGetValue $filePathConfigHideNum imei显示 info)"
                #content=${content}${enterLine}"工程模式：$(ftIniGetValue $filePathConfigHideNum 工程模式 info)"
                #content=${content}${enterLine}"硬件信息查看：$(ftIniGetValue $filePathConfigHideNum 硬件信息查看 info)"
                #content=${content}${enterLine}"sn码显示：$(ftIniGetValue $filePathConfigHideNum sn码 info)"
            #else
                #content=${content}${enterLine}"隐藏指令："
                #content=${content}${enterLine}"imei编辑："
                #content=${content}${enterLine}"imei显示：*#06#"
                #content=${content}${enterLine}"测试模式：*#*#180#*#*"
                #content=${content}${enterLine}"imei单双切换："
            #fi

            #git log 列表
            echo -e "﻿$gitCommitListBefore">$filePathChangeListTemplate
            seq 10 | awk '{printf("    %02d %s\n", NR, $0)}' $filePathChangeListTemplate >${filePathChangeListTemplate}.temp

            # 合并头部和git log 列表
            echo -e ${content}${enterLine}${enterLine}"git commit 记录："| cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate

            # 转化为windows下面文件格式
            unix2dos $filePathChangeListTemplate
    fi

    ftEcho -s "生成 ${filePathChangeListTemplate}"
    rm ${filePathChangeListTemplate}.temp
    cd $dirPathLocal
    trap  SIGINT
}

ftAutoLanguageUtil()
{
    local ftEffect=语言缩写转化为中文
    local isEnable=true

    while true; do case "$1" in
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    ftAutoLanguageUtil 无参
#========================================================="; return ;;
    --env ) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
    [ ! -d "$dirPathCode" ]||[ -z "$targetProduct" ] && ftAutoLanguageUtil --env && return
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP targetProduct=$TARGET_PRODUCT filePathDataBase=$rFilePathXbashDataBase
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -f "$filePathDataBase" ] && errorContent="${errorContent}\\n[语言转化配置库不存在]filePathDataBase=$filePathDataBase"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoLanguageUtil -h && return

    #实现主体
    local filePathDeviceProductLocales=($(ftIniGetValue $filePathDataBase lzProjrctConfigProductLocales $targetProduct))
    filePathDeviceProductLocales=${dirPathCode}/${filePathDeviceProductLocales}

    if [[ ! -f "$filePathDeviceProductLocales" ]]; then
        ftEcho -sn "语言转化配置文件不存在: "
        ftEcho -e "$filePathDeviceProductLocales"
        ftAutoLanguageUtil -h
        return
    fi
    local key="PRODUCT_LOCALES := "
    local LanguageList=$(cat $filePathDeviceProductLocales|grep "$key"|grep -v "#PRODUCT_LOCALES := ")
    LanguageList=${LanguageList//$key/}
    ftLanguageUtil "${LanguageList[@]}"
}

complete -W "-rc -rt -e -p -h -d" ftAutoTest
ftAutoTest()
{
    local ftEffect=AndroidMonkey测试
    local isEnable=true

    while true; do case "$1" in
     --rely) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明=============
#    adb当前无法正常使用， 请确认 Android SDK 配置是否正确
#========================================================="; return;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#    #-xx 为独立参数类型标识,不可拆分
#    #参数之间没有先后约束
#
#    ftAutoTest -p "com.xx com.yy.zz" #只测试的包名
#    ftAutoTest -pb "com.xx com.yy.zz" #禁止测试的包名
#    ftAutoTest -d /home/xxx/xxx    # log存放路径
#    ftAutoTest -rc 3000    2000        #每3000s重启一次,重启2000次
#    ftAutoTest -e 2000             #monkey事件数为2000
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ]&&  ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
     [[ -z $(which adb) ]] && ftAutoTest --rely && return
    #解参验耦
    local editType=$1
    local eventCountDef=$(( 100 * 100 *100 )) rebootTimeLongDef=-1 rebootCountDef=1
    local eventCount=$eventCountDef rebootTimeLong=$rebootTimeLongDef rebootCount=$rebootCountDef dirPathLogRoot=~/log
    local packageNameList packageBlackNameList packageWhiteNameList
    local arg  arg2 arg3 index ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}}
        ((index=i+1)) ;eval arg2=\${${index}}
        ((index=i+2)) ;eval arg3=\${${index}}
        case "${arg}" in
              -p)     packageNameList=${arg2}                            ;;
              -pb)   packageBlackNameList=${arg2}                   ;;
              -d)     dirPathLogRoot=${arg2:-'dirPathLogRoot'}          ;;
              -rc)    rebootTimeLong=${arg2:-'rebootTimeLongDef'}
                       rebootCount=${arg3:-'rebootCountDef'}  ;;
              -e)     eventCount=${arg2:-'eventCountDef'}                   ;;
    * ) [[ -z "${arg}" ]] &&  break ;; esac;done
    local errorContent
    (($rebootTimeLong!=$rebootTimeLongDef))&&( ! echo -n $rebootTimeLong | grep -q -e "^[0-9][0-9]*$") && errorContent="${errorContent}\\n[时长必须为数字[单位S]]rebootTimeLong=$rebootTimeLong"
    [[ -n $packageBlackNameList ]]&&[[ -n $packageNameList ]] && errorContent="${errorContent}\\n 包限制配置错误1"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoTest -h && return

    #实现主体
    local filePathDeviceInfo=/system/build.prop
    local dirPathLogMonkeyBase=${dirPathLogRoot}/monkey
    local dirNameLogMonkey=$(date -d "today" +"%y%m%d%H%M%S")
    local dirPathLogMonkey=${dirPathLogMonkeyBase}/${dirNameLogMonkey}
    local filePathLogMonkey=${dirPathLogMonkey}/monkey.log
    local filePathLogAdbLogcat=${dirPathLogMonkey}/logcat.log
    local dirPathDevicesTarget="/storage/sdcard0"
    local monkeyConfig logcatFlag #="*:E"

    # monkey命令参数配置
        # monkeyConfig=${monkeyConfig}" --wait-dbg"
        monkeyConfig=${monkeyConfig}" --ignore-crashes --ignore-timeouts --ignore-security-exceptions"
        if [[ -n $packageBlackNameList ]]; then
            local fileNameBlack="monkey.blacklist"
            local filePathBlack="${rDirPathUserHome}/temp/${fileNameBlack}"
            rm -rf $filePathBlack
            for packageName in ${packageBlackNameList[@]} ; do echo package:${packageName} >> $filePathBlack ;done
            adb push $filePathBlack $dirPathDevicesTarget && monkeyConfig=${monkeyConfig}" --pkg-blacklist-file ${filePathBlack}"

        elif [[ -n $packageNameList ]]; then
            if ((${#packageNameList[@]}>1)); then
                local fileNameWhite="monkey.whitelist"
                local filePathWhite="${rDirPathUserHome}/temp/${fileNameWhite}"
                rm -rf $filePathWhite
                for packageName in ${packageWhiteNameList[@]} ; do echo package:${packageName} >> $filePathWhite ;done
                adb push $filePathWhite $dirPathDevicesTarget && monkeyConfig=${monkeyConfig}" --pkg-whitelist-file ${filePathWhite}"
            else
                monkeyConfig=${monkeyConfig}" -p ${packageNameList}"
            fi
        fi
        monkeyConfig=${monkeyConfig}" -v -v -v"
        monkeyConfig=${monkeyConfig}" ${eventCount}"

    #adb状态确认
        ftEcho -s "等待设备连接" && adb wait-for-device && ftEcho -s "连接设备成功"
        local adbStatus=$(adb get-state)
        [ "$adbStatus" != "device" ] && ftEcho -e "adb连接状态[$adbStatus]异常,请重新尝试" && return
    #环境清理
        for folder in $(ls $dirPathLogMonkeyBase); do  [[ ! $folder =~ "done" ]] && rm -rf ${dirPathLogMonkeyBase}/${folder} ;done
        [[ ! -d $dirPathLogMonkey ]] && mkdir -p $dirPathLogMonkey
        adb logcat -c
    #无效进程清理
        for pid in $(ps -ef |grep adb |grep logcat |awk '{print $2}'); do kill -9 $pid  ;done
        ftKillApplicationByPackageName monkey > /dev/null
    #记录设备信息
        adb pull $filePathDeviceInfo $dirPathLogMonkey > /dev/null&& ftEcho -s "设备信息已保存到${dirPathLogMonkey}"
    #开始测试
        if (( $rebootCount==$rebootCountDef ));then
                echo monkeyConfig=${monkeyConfig[@]}
                adb logcat "$logcatFlag" > $filePathLogAdbLogcat &
                adb shell monkey "${monkeyConfig}" 2>&1 |tee $filePathLogMonkey
        else
                while true; do
                    ftEcho -s "等待设备连接" && adb wait-for-device && ftEcho -s "连接设备成功"
                    [ "$(adb get-state)" != "device" ] && ftEcho -e "设备连接状态异常,请重新尝试" && break
                    tput sc ; while [[ -z $(adb shell ps |grep launcher) ]]; do
                        tput rc;tput ed
                        ftEcho -sn "等待launcer启动..."
                        sleep 5
                    done ;echo

                    if (($rebootTimeLong!=$rebootTimeLongDef)); then
                        timeout $rebootTimeLong adb shell monkey "$monkeyConfig" 2>&1 >> $filePathLogMonkey &
                        timeout $rebootTimeLong adb logcat "$logcatFlag" |tee -a $filePathLogAdbLogcat
                    else
                        adb logcat "$logcatFlag" |tee -a $filePathLogAdbLogcat &
                        adb shell monkey "$monkeyConfig" 2>&1 |tee $filePathLogMonkey
                    fi

                    rebootCount=$((rebootCount - 1))
                    if (( $rebootCount>0 )); then
                        ftEcho -s "开始设备重启"
                        adb reboot
                    else
                        break
                    fi
            done
        fi
    #扫尾
        for pid in $(ps -ef |grep adb |grep logcat |awk '{print $2}'); do kill -9 $pid  ;done
        [[ -n $(adb shell ls ${dirPathDevicesTarget}/mtklog) ]] && ftEcho -s "正在导出mtklog,请稍等..." && adb pull ${dirPathDevicesTarget}/mtklog $dirPathLogMonkey
        mv $dirPathLogMonkey ${dirPathLogMonkey}_done
}

complete -W "-t -h --help" ftAutoAddGitTag
ftAutoAddGitTag()
{
    local ftEffect=添加git的TAG
    local isEnable=true

    while true; do case "$1" in
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的依赖说明=============
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#
#    ftAutoAddGitTag -t
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #依赖校验
    [[ -z $(which git) ]] && ftExample --rely "git" && return
    #解参验耦
    local valCount=1 errorContent index arg arg2
    local tagName noteContent
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; ((index=i+1)) ; eval arg2=\${${index}}
    case "${arg}" in
        -t ) tagName="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    # (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[示例1]tagName=$tagName"
    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoAddGitTag -h && return

    #实现主体
    local fileNameVersionNote="${tagName}的相应说明"
    local filePathVersionNote=/tmp/${fileNameVersionNote}
    if [ -n "$(pgrep -f gedit)" ];then
            while true; do echo && ftEcho -y gedit 已打开是否关闭
            read -n 1 sel
            case "$sel" in
                y | Y )    kill -9 $(ps -e|grep gedit |awk '{print $1}') ; break;;
                n | N |q | Q)    return;;
                * ) ftEcho -e 错误的选择：$sel && echo "输入n,q，离开" ; ;;
            esac ; done
    fi
    if touch $filePathVersionNote ; then
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit $filePathVersionNote
    else
        ftEcho -ex "创建临时说明信息文件失败"
        return;
    fi

    noteContent=$(cat $filePathVersionNote) ;rm -rf $filePathVersionNote

    if [[ -z "$noteContent" ]];then
        echo -n "空的备注信息，是否使用commit名作为备注信息[y/n] (回车默认y)"
        read -n 1 sel ;[ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    noteContent=$(ftGitLogShell -t "%s" -n 1) ; break;;
                n | q )  echo ;
                    return ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
    esac;done ; fi

    [[ -n "$noteContent" ]] && git tag -a "$tagName" -m "${noteContent[@]}"
}

complete -W "-h --help --rely_install" ftAutoCreateBranch
ftAutoCreateBranch()
{
    local ftEffect=自动生成stxd老项目的分支
    local isEnable=true

    while true; do case "$1" in
    --rely) echo -e "\
#===================[   ${ftEffect}   ]的依赖说明=============
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get update
            sudo apt-get install git
            return ;;
    -h | --help) echo -e "\
#===================[   ${ftEffect}   ]的使用示例==============
#
#    ftAutoCreateBranch  #无参数
#========================================================="; return ;;
    --env) echo -e "\
#===================[   ${ftEffect}   ]的使用环境说明==============
# 环境未初始化
# 使用前,请先进入AOSP项目
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #环境校验
    if [[ -z "$ANDROID_BUILD_TOP" ]];then
        [[ -d "alps" ]]&&[[ -d ".git" ]]&&cd alps
        ftAutoInitEnv > /dev/null
    fi
    local dirPathAospRoot=$(dirname $ANDROID_BUILD_TOP)
    [[ ! -d "${dirPathAospRoot}" ]] && ftAutoCreateBranch --env && return
    cd $dirPathAospRoot
    #依赖校验
    [[ -z $(which git) ]] && ftAutoCreateBranch --rely "git" && return
    #解参验耦
    local valCount=1 errorContent index arg arg2
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoCreateBranch -h && return

    #实现主体
    local hashValBase=$(ftGitLogShell -t "%h" -n 1)
    git reset > /dev/null
    git add $(git status --porcelain |grep -v "alps/out" | sed s/??//g | sed -e "s: M ::g"|grep "alps/") > /dev/null
    git status --porcelain

    echo -n "请确认待commit修改列表,是否正确 [y/n] (回车默认y)"
    read -n 1 sel ;[ -z "${sel}" ] && sel=y
    while true; do case "$sel" in
            y | Y )
                local tarPackagAutoCreateName=0tempBranch tarPackagAutoCreateNameTemp=temp
                ls | while read line;do
                    [[ ! -d "$line" ]] && continue
                    if [[  ${line//$tarPackagAutoCreateName} != $line ]]; then
                        local dirPath=${line}
                        local dirPath_old=${dirPath}_old
                        [[ -d "$dirPath_old" ]] && dirPath_old=${dirPath_old}_old
                        mv $dirPath $dirPath_old
                    fi
                done

                ftEcho -s "开始添加临时commit"
                git commit -m "temp" > /dev/null
                local hashValTemp=$(ftGitLogShell -t "%h" -n 1)
                git diff $hashValTemp $hashValBase --name-only | xargs tar -rf ${tarPackagAutoCreateName}.tar

                mkdir $tarPackagAutoCreateNameTemp
                tar -xvf ${tarPackagAutoCreateName}.tar -C ${tarPackagAutoCreateNameTemp}
                mv ${tarPackagAutoCreateNameTemp}/alps ${tarPackagAutoCreateName}
                rm -rf $tarPackagAutoCreateNameTemp ${tarPackagAutoCreateName}.tar
                ftEcho -s "已生成临时分支: ${tarPackagAutoCreateName}"

                break;;
            n | q )  echo ;
                return ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
    esac;done ;
    git reset $hashValBase > /dev/null && ftEcho -s "已删除临时commit"
}