#!/bin/bash
#####---------------------工具函数---------------------------#########
ftKillPhoneAppByPackageName()
{
	local ftName=根据应用包名杀死应用
	local packageName=$1

	#使用示例
	while true; do case "$1" in    h | H |-h | -H) cat<<EOF
	#=================== ${ftName}的使用示例=============
	#
	#	ftKillPhoneAppByPackageName [packageName]
	#	ftKillPhoneAppByPackageName com.android.settings
	#=========================================================
EOF
	exit;; * )break;; esac;done

	#耦合变量校验
	local valCount=1
	if [ $# -ne $valCount ]||[ -z "$packageName" ];then
		  ftEcho -e "函数[${ftName}]参数错误，请查看函数使用示例"
		  ftKillPhoneAppByPackageName -h
	fi

	#adb状态检测
	adbStatus=`adb get-state`
	if [ $adbStatus =  "device" ];then
		#确定包存在
		if [ -n "$(adb shell pm list packages|grep $packageName)" ];then
			adb root
			adb remount
			pid=`adb shell ps | grep $packageName | awk '{print $2}'`
			#pid=`adb shell "ps" | awk '/com.android.systemui/{print $2}'`
			adb shell kill $pid
		else
			ftEcho -e 包名[${packageName}]不存在，请确认
		fi
	else
		ftEcho -e adb状态异常,请重新尝试
	fi
}

ftRestartadb()
{
	#耦合变量校验
	local valCount=0
	if [ $# -ne $valCount ]||[ -z "$mUserPwd" ];then
		  ftEcho -ex "函数[${ftName}]参数错误"
	fi

	local ftName=重启adb sever
	echo $mUserPwd | sudo -S adb kill-server
	echo
	sleep 2
	echo $mUserPwd | sudo -S adb start-server
	echo server-start
	adb devices
}

ftCleanDataGarbage()
{
	local ftName=清空回收站
	dirDevsArray=(
			/media/data_self \
			/home/${mUserName} \
			)

	for dirDev in ${dirDevsArray[*]}
	do
	dir=null
	if [ -d ${dirDev}/.Trash-1000 ];then
		dir=${dirDev}/.Trash-1000
	else
		if [ -d ${dirDev}/.local/share/Trash ];then
			dir=${dirDev}/.local/share/Trash
		fi
	fi

	if [ -d $dir ];then
		cd $dir
		if [ ! -d empty ];then
			mkdir empty
		fi
		rsync --delete-before -d -a -H -v --progress --stats empty/ files/
		rm -rf files/*
		fi
	done
}

ftMtkFlashTool()
{
	local ftName=mtk下载工具
	local tempDirPath=`pwd`
	local toolDirPath=${mRoDirPathTools}sp_flash_tool_v5.1548

	#耦合变量校验
	local valCount=0
	if [ $# -ne $valCount ]||[ -z "$tempDirPath" ]\
			         ||[ -z "$mRoDirPathTools" ];then
		  ftEcho -ex "函数[${ftName}]参数错误"
	fi

	cd $toolDirPath&&
	echo "$mUserPwd" | sudo -S ./flash_tool&&
	cd $tempDirPath
}

ftFileDirEdit()
{
	local ftName=路径合法性校验
	type=$1
	isCreate=$2
	path=$3

	#使用示例
	while true; do case "$1" in    h | H |-h | -H) cat<<EOF
	#=================== ${ftName}的使用示例===================
	#
	#		ftFileDirEdit [type] [isCreate] [path]
	#		ftFileDirEdit f true /home/xian-hp-u16/cmds/test.sh
	#		echo $?
	#=========================================================
EOF
	exit;; * )break;; esac;done

	#耦合变量校验
	local valCount=3
	if [ $# -ne $valCount ]||[ -z "$type" ]\
					         ||[ -z "$isCreate" ]\
					         ||[ -z "$path" ];then
		  ftEcho -e "函数[${ftName}]参数错误，请查看函数使用示例"
		  ftFileDirEdit -h
	fi

	if [ $type = "f" ];then

		if [ -f $path ];then
			return 1
		elif [ $isCreate = "true" ];then
			touch $path
			return 1
		else
			return 0
		fi

	elif [ $type = "d" ];then

		if [ -d $path ];then
			return 1
		elif [ $isCreate = "true" ];then
			mkdir -p $path
			return 1
		else
			return 0
		fi

	else
		echo 函数[[${ftName}]]调用时使用了错误参数
		return 0
	fi
}
ftDebug()
{
	local ftName=调试用，实时跟踪变量变化

	#使用示例
	while true; do case "$1" in    h | H |-h | -H) cat<<EOF
	#=================== ${ftName}的使用示例===================
	#
	#	 trap 'echo “行:$LINENO, a=$a,b=$b,c=$c”' DEBUG
	#	 根据需要修改 a，b，c
	#	mRoIsDebug设为true
	#	 ftDebug [任意命令]
	#	 ftDebug echo test
	#=========================================================
EOF
	exit;; * )break;; esac;done

	#耦合变量校验
	if [ -z "$mRoIsDebug" ];then
		  ftEcho -ex "函数[${ftName}]参数错误，请查看函数使用示例"
	fi

	 if [ "$mRoIsDebug" = "true" ]; then
		$@
		trap 'echo “行:$LINENO, mRoBaseShellParameter2=$mRoBaseShellParameter2,\
	 			 commandAuthority=$commandAuthority,\
	 			 XCMD=$XCMD”' DEBUG
	 else
	 	ftEcho -ex 当前非调试模式
	fi

}

ftEcho()
{
#=================== example=============================
#
#	 ftEcho [option] [Content]
#	 ftEcho e 错误的选择1
#=========================================================
	local ftName=工具信息提示
	option=$1
	Content=$2
	while true; do
	case $option in
	#错误信息显示
	e | E | -e | -E)	echo -e "\033[31m$Content\033[0m"; break;;
	#错误信息显示，显示退出
	ex | EX | -ex | -EX)	echo -e "\033[31m$Content\033[0m"; exit;;
	#执行信息
	s | S | -s | -S)	echo;echo -e "\033[44m$Content\033[0m"; break;;
	# 标题，不换行
	t | T | -t | -T)	echo -e "\e[41;33;1m =========== $Content ============= \e[0m"; break;;
	# 标题，换行
	b | B | -b | -B)	echo;echo -e "\e[41;33;1m =========== $Content ============= \e[0m";echo; break;;
	#特定信息显示,y/n
	y | Y | -y | -Y)	echo -en "${Content}[y/n]"; break;;
	# 特定信息显示,命令说明的格式
	g | G | -g | -G)cat<<EOF
=========================================================================
命令	--- 参数/命令说明
	|// 使用格式
	|-- 参数	 ---------------- [参数权限] ----	参数说明
=========================================================================
EOF
break;;
	* ) echo $option ;break;;
	esac
	done
}

ftTiming()
{
	local ftName=脚本操作耗时记录

	if [ -z "$mTimingStart" ];then
		mTimingStart=$(date +%s -d $(date +"%H:%M:%S"))
		return 0;
	fi

	 #时间少于1秒默认不显示操作耗时
	 #时间时分秒各单位不显示为零的结果
	time2=$(date +%s -d $(date +"%H:%M:%S"))
	time3=$(((time2-mTimingStart)%60))
	time5=$(((time2-mTimingStart)/3600))
	time4=$((((time2-mTimingStart)-time5*3600)/60))

	if [ "$time5" -ne "0" ];then
		strS1=$time5时
	else
		strS1=""
	fi
	if [ "$time4" -ne "0" ];then
		strF1=$time4分
	else
		strF1=""
	fi
	if [ "$time3" -ne "0" ];then
		strM1=$time3秒
	else
		strM1=""
	fi
	if [ "$time3" -eq "0" ]&&[ "$time4" -eq "0" ] &&[ "$time5" -eq "0" ];then
		ftEcho -s 1秒没到就结束了
	else
		 ftEcho -s "本技能耗时${strS1}${strF1}${strM1}  !"
	fi
	mTimingStart=
}